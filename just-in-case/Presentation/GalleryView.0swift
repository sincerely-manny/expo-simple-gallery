import ExpoModulesCore
import Photos
import UIKit

class GalleryView: UICollectionView, UICollectionViewDataSource,
  UICollectionViewDelegateFlowLayout
{
  private var columns: Int = 3  // Number of columns
  private var imageAspectRatio: CGFloat = 1 / 1  // Aspect ratio: width / height
  private var spacing: CGFloat = 0  // Spacing between items
  private var borderRadius: CGFloat = 0

  private var photoAssets: [PHAsset] = []
  private var uris: [String] = []

  private var overlaysCollection = [Int: WeakViewReference]()
  private let overlayLock = NSLock()

  class WeakViewReference {
    weak var view: UIView?
    init(_ view: UIView) {
      self.view = view
    }
  }

  init() {
    let layout = UICollectionViewFlowLayout()
    super.init(frame: .zero, collectionViewLayout: layout)
    backgroundColor = .clear
    dataSource = self
    delegate = self
    register(PhotoCell.self, forCellWithReuseIdentifier: PhotoCell.identifier)
  }

  required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }

  func setAssets(_ assets: [String]) {
    uris = assets
    updateLayout(animated: false)
  }

  func mountOverlay(index: Int, overlay: UIView) {
    assert(Thread.isMainThread)

    overlayLock.lock()
    defer { overlayLock.unlock() }

    overlaysCollection[index] = WeakViewReference(overlay)

    if let visibleCell = self.cellForItem(at: IndexPath(item: index, section: 0)) as? PhotoCell {
      visibleCell.setOverlay(overlay)
    }
  }

  func unmountOverlay(index: Int) {
    assert(Thread.isMainThread)

    overlayLock.lock()
    defer { overlayLock.unlock() }

    overlaysCollection.removeValue(forKey: index)

    if let visibleCell = self.cellForItem(at: IndexPath(item: index, section: 0)) as? PhotoCell {
      visibleCell.clearOverlay()
    }
  }

  func setColumns(_ count: Int, animated: Bool = true) {
    guard count > 0 else { return }
    columns = count
    collectionViewLayout.invalidateLayout()
    reloadData()
    if animated {
      UIView.animate(withDuration: 0.3) {
        self.layoutIfNeeded()
      }
    }
  }

  func setImageAspectRatio(_ ratio: CGFloat, animated: Bool = true) {
    guard ratio > 0 else { return }
    imageAspectRatio = ratio
    updateLayout(animated: animated)
  }

  func setSpacing(_ value: CGFloat, animated: Bool = true) {
    guard value >= 0 else { return }
    spacing = value
    updateLayout(animated: animated)
  }

  func setBorderRadius(_ radius: CGFloat, animated: Bool = true) {
    borderRadius = radius
    updateLayout(animated: animated)
  }

  // TODO: Exhaust possible styles

  func setThumbnailStyle(_ style: [String: Any], animated: Bool = true) {
    for styleKey in style.keys {
      guard let styleProp = style[styleKey] as? String else { continue }
      print(styleKey, styleProp)
    }
  }

  private func updateLayout(animated: Bool) {
    collectionViewLayout.invalidateLayout()
    if animated {
      UIView.animate(
        withDuration: 0.3,
        animations: {
          self.layoutIfNeeded()
        })
    } else {
      reloadData()
    }
  }

  // MARK: - UICollectionViewDataSource

  func collectionView(
    _ collectionView: UICollectionView, numberOfItemsInSection section: Int
  ) -> Int {
    return uris.count
  }

  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
    guard
      let cell = collectionView.dequeueReusableCell(
        withReuseIdentifier: PhotoCell.identifier,
        for: indexPath
      ) as? PhotoCell
    else {
      return UICollectionViewCell()
    }

    let uri = uris[indexPath.item]
    cell.configure(with: uri)
    cell.setBorderRadius(borderRadius)

    // Update overlay if exists
    if let overlay = overlaysCollection[indexPath.item]?.view {
      overlay.isHidden = false
      overlay.alpha = 1
      cell.setOverlay(overlay)
    } else {
      cell.clearOverlay()
    }

    return cell
  }

  // MARK: - UICollectionViewDelegateFlowLayout

  func collectionView(
    _ collectionView: UICollectionView,
    layout collectionViewLayout: UICollectionViewLayout,
    sizeForItemAt indexPath: IndexPath
  ) -> CGSize {
    //    let scale = UIScreen.main.scale
    let totalSpacing = CGFloat(max(columns - 1, 0)) * spacing
    let usableWidth = collectionView.bounds.width - totalSpacing

    let cellWidth: CGFloat
    if columns == 1 {
      // Ensure full width for single-column layout
      cellWidth = floor(collectionView.bounds.width)
    } else {
      cellWidth = floor((usableWidth / CGFloat(columns)))
    }

    let cellHeight = floor((cellWidth / imageAspectRatio))
    //    print("Cell size for index \(indexPath.item): \(CGSize(width: cellWidth, height: cellHeight))")
    return CGSize(width: cellWidth, height: cellHeight)
  }

  func collectionView(
    _ collectionView: UICollectionView,
    layout collectionViewLayout: UICollectionViewLayout,
    insetForSectionAt section: Int
  ) -> UIEdgeInsets {
    if columns == 1 {
      return .zero  // No insets for single-column layout
    } else {
      return UIEdgeInsets(top: spacing, left: 0, bottom: spacing, right: 0)
    }
  }

  func collectionView(
    _ collectionView: UICollectionView,
    layout collectionViewLayout: UICollectionViewLayout,
    minimumInteritemSpacingForSectionAt section: Int
  ) -> CGFloat {
    return spacing
  }

  func collectionView(
    _ collectionView: UICollectionView,
    layout collectionViewLayout: UICollectionViewLayout,
    minimumLineSpacingForSectionAt section: Int
  ) -> CGFloat {
    return spacing
  }
}
