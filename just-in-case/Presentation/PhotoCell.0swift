import Photos
import UIKit

class PhotoCell: UICollectionViewCell {
  static let identifier = "PhotoCell"
  private let imageView = UIImageView()
  private let overlayContainer = UIView()
  private weak var overlayView: UIView?
  private var imageLoadTask: DispatchWorkItem?

  override init(frame: CGRect) {
    super.init(frame: frame)

    // Setup imageView
    contentView.addSubview(imageView)
    imageView.translatesAutoresizingMaskIntoConstraints = false
    imageView.contentMode = .scaleAspectFill
    imageView.clipsToBounds = true
    imageView.layer.minificationFilter = .trilinear
    imageView.layer.shouldRasterize = true
    imageView.layer.rasterizationScale = UIScreen.main.scale

    // Setup overlayContainer
    contentView.addSubview(overlayContainer)
    overlayContainer.translatesAutoresizingMaskIntoConstraints = false

    NSLayoutConstraint.activate([
      imageView.topAnchor.constraint(equalTo: contentView.topAnchor),
      imageView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
      imageView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
      imageView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),

      overlayContainer.topAnchor.constraint(equalTo: contentView.topAnchor),
      overlayContainer.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
      overlayContainer.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
      overlayContainer.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
    ])
  }

  required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }

  // TODO: Resized caching, resize cancellation

  private func resizeImage(_ image: UIImage, targetSize: CGSize) -> UIImage {
    let size = image.size

    let widthRatio = targetSize.width / size.width
    let heightRatio = targetSize.height / size.height

    let scaleFactor = min(widthRatio, heightRatio)

    let scaledSize = CGSize(
      width: size.width * scaleFactor,
      height: size.height * scaleFactor
    )

    let renderer = UIGraphicsImageRenderer(size: scaledSize)
    let resizedImage = renderer.image { _ in
      image.draw(in: CGRect(origin: .zero, size: scaledSize))
    }

    return resizedImage
  }

  func configure(with asset: PHAsset) {
    let manager = PHImageManager.default()
    let options = PHImageRequestOptions()
    options.isSynchronous = true
    options.resizeMode = .fast

    let targetSize = CGSize(
      width: contentView.bounds.width * UIScreen.main.scale,
      height: contentView.bounds.height * UIScreen.main.scale
    )

    manager.requestImage(
      for: asset,
      targetSize: targetSize,
      contentMode: .aspectFill,
      options: options
    ) { [weak self] image, _ in
      self?.imageView.image = image
    }
  }

  func configure(with uri: String) {
    // Cancel any pending image load
    imageLoadTask?.cancel()

    guard let url = URL(string: uri) else { return }
    let targetSize = CGSize(
      width: contentView.bounds.width * UIScreen.main.scale,
      height: contentView.bounds.height * UIScreen.main.scale
    )

    let task = DispatchWorkItem { [weak self] in
      guard let self = self else { return }

      switch url.scheme {
      case "file":
        if let originalImage = UIImage(contentsOfFile: url.path) {
          let resizedImage = self.resizeImage(originalImage, targetSize: targetSize)
          DispatchQueue.main.async {
            self.imageView.image = resizedImage
          }
        }

      case "ph":
        let assetID = uri.replacingOccurrences(of: "ph://", with: "")
        if let asset = PHAsset.fetchAssets(withLocalIdentifiers: [assetID], options: nil).firstObject {
          let manager = PHImageManager.default()
          let options = PHImageRequestOptions()
          options.resizeMode = .fast
          options.deliveryMode = .opportunistic

          manager.requestImage(
            for: asset,
            targetSize: targetSize,
            contentMode: .aspectFill,
            options: options
          ) { [weak self] image, _ in
            DispatchQueue.main.async {
              self?.imageView.image = image
            }
          }
        }

      default:
        print("Unsupported URI scheme:", url.scheme ?? "none")
      }
    }

    imageLoadTask = task
    DispatchQueue.global(qos: .userInitiated).async(execute: task)
  }

  func setOverlay(_ overlay: UIView) {
    assert(Thread.isMainThread)

    // If it's the same view, do nothing
    if overlay === overlayView { return }

    clearOverlay()
    overlayView = overlay

    // Just add the overlay to our container - it should already be properly configured
    overlayContainer.addSubview(overlay)
  }

  func clearOverlay() {
    overlayView?.removeFromSuperview()
    overlayView = nil
  }

  override func prepareForReuse() {
    super.prepareForReuse()
    imageLoadTask?.cancel()
    imageLoadTask = nil
    imageView.image = nil
    clearOverlay()
  }

  func setBorderRadius(_ radius: CGFloat) {
    contentView.layer.cornerRadius = radius
    contentView.layer.masksToBounds = true
  }

}
